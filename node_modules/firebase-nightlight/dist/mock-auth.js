"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var eventemitter2_1 = require("eventemitter2");
var mock_error_1 = require("./mock-error");
var mock_user_1 = require("./mock-user");
var MockAuth = (function () {
    function MockAuth(options) {
        this.app_ = options.app;
        this.currentUser_ = null;
        this.emitter_ = new eventemitter2_1.EventEmitter2();
        this.identities_ = options.identities;
    }
    Object.defineProperty(MockAuth.prototype, "app", {
        get: function () {
            return this.app_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockAuth.prototype, "currentUser", {
        get: function () {
            return this.currentUser_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockAuth.prototype, "languageCode", {
        get: function () {
            throw mock_error_1.unsupported_();
        },
        enumerable: true,
        configurable: true
    });
    MockAuth.prototype.applyActionCode = function (code) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.checkActionCode = function (code) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.confirmPasswordReset = function (code, password) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.createCustomToken = function (uid, developerClaims) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.createUser = function (properties) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.createUserWithEmailAndPassword = function (email, password) {
        var identity = this.identities_.find(function (identity) { return identity.email === email; });
        if (identity) {
            return Promise.reject(mock_error_1.error_("auth/email-already-in-use", "Email already in use."));
        }
        identity = { email: email, password: password };
        this.identities_.push(identity);
        this.currentUser_ = new mock_user_1.MockUser({ email: email });
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve(this.currentUser_);
    };
    MockAuth.prototype.deleteUser = function (uid) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.fetchProvidersForEmail = function (email) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.getRedirectResult = function () {
        return Promise.resolve({
            credential: null,
            user: null
        });
    };
    MockAuth.prototype.getUser = function (uid) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.getUserByEmail = function (email) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.listUsers = function (maxResults, pageToken) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.onAuthStateChanged = function (nextOrObserver, errorCallback, completedCallback) {
        var _this = this;
        var nextCallback;
        if (typeof nextOrObserver === "function") {
            errorCallback = errorCallback || (function () { });
            nextCallback = nextOrObserver;
        }
        else {
            errorCallback = function (error) { nextOrObserver["error"](error); };
            nextCallback = function (value) { nextOrObserver["next"](value); };
        }
        this.emitter_.on("auth", nextCallback);
        this.emitter_.on("error", errorCallback);
        setTimeout(function () { return _this.emitter_.emit("auth", _this.currentUser_); }, 0);
        return function () {
            _this.emitter_.off("auth", nextCallback);
            _this.emitter_.off("error", errorCallback);
        };
    };
    MockAuth.prototype.onIdTokenChanged = function (nextOrObserver, error, completed) {
        return this.onAuthStateChanged(nextOrObserver, error, completed);
    };
    MockAuth.prototype.sendPasswordResetEmail = function (email) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.setPersistence = function (persistence) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.signInAndRetrieveDataWithCredential = function (credential) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.signInAnonymously = function () {
        this.currentUser_ = new mock_user_1.MockUser({ email: undefined });
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve(this.currentUser_);
    };
    MockAuth.prototype.signInWithCredential = function (credential) {
        var identity = this.identities_.find(function (identity) { return identity.credential === credential; });
        if (!identity) {
            return Promise.reject(mock_error_1.error_("auth/invalid-credential", "Invalid credential."));
        }
        this.currentUser_ = new mock_user_1.MockUser({
            email: identity.email,
            uid: identity.uid
        });
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve(this.currentUser_);
    };
    MockAuth.prototype.signInWithCustomToken = function (token) {
        var identity = this.identities_.find(function (identity) { return identity.token === token; });
        if (!identity) {
            return Promise.reject(mock_error_1.error_("auth/invalid-custom-token", "Invalid token."));
        }
        this.currentUser_ = new mock_user_1.MockUser({
            email: identity.email,
            uid: identity.uid
        });
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve(this.currentUser_);
    };
    MockAuth.prototype.signInWithEmailAndPassword = function (email, password) {
        var identity = this.identities_.find(function (identity) { return identity.email === email; });
        if (!identity) {
            return Promise.reject(mock_error_1.error_("auth/user-not-found", "User not found."));
        }
        if (identity.password !== password) {
            return Promise.reject(mock_error_1.error_("auth/wrong-password", "Wrong password."));
        }
        this.currentUser_ = new mock_user_1.MockUser({
            email: identity.email,
            uid: identity.uid
        });
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve(this.currentUser_);
    };
    MockAuth.prototype.signInWithPhoneNumber = function (phoneNumber, applicationVerifier) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.signInWithPopup = function (provider) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.signInWithRedirect = function (provider) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.signOut = function () {
        this.currentUser_ = null;
        this.emitter_.emit("auth", this.currentUser_);
        return Promise.resolve();
    };
    MockAuth.prototype.updateUser = function (uid, properties) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.useDeviceLanguage = function () {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.verifyIdToken = function (idToken) {
        throw mock_error_1.unsupported_();
    };
    MockAuth.prototype.verifyPasswordResetCode = function (code) {
        throw mock_error_1.unsupported_();
    };
    return MockAuth;
}());
exports.MockAuth = MockAuth;
