"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var json = require("./json");
var lodash = require("./lodash");
var eventemitter2_1 = require("eventemitter2");
var firebase_key_1 = require("firebase-key");
var mock_data_snapshot_1 = require("./mock-data-snapshot");
var mock_error_1 = require("./mock-error");
var lastRefId = 0;
var MockRef = (function () {
    function MockRef(options) {
        this.app_ = options.app;
        this.database_ = options.database;
        this.emitters_ = options.emitters;
        this.id_ = ++lastRefId;
        this.jsonPath_ = toJsonPath(options.path || "");
        this.path_ = toRelativePath(lodash.trim(options.path || "", "/"));
        this.promise_ = options.promise;
        this.query_ = options.query || {};
        this.queue_ = [];
        if (this.path_ === ".info") {
            this.database_.content = this.database_.content || {};
            this.database_.content[".info"] = this.database_.content[".info"] || {
                connected: true,
                serverTimeOffset: 0
            };
        }
        else if (/[\.\$\[\]#]/.test(this.path_)) {
            throw new Error("Illegal characters in path.");
        }
        this.refEmitter_ = new eventemitter2_1.EventEmitter2();
        this.refEmitterBindings_ = [];
        this.rootEmitter_ = this.emitters_.root;
        this.sharedEmitter_ = this.emitters_.shared[this.jsonPath_];
        if (!this.sharedEmitter_) {
            this.sharedEmitter_ = new eventemitter2_1.EventEmitter2({ wildcard: true });
            this.emitters_.shared[this.jsonPath_] = this.sharedEmitter_;
        }
        this.sharedEmitter_.onAny(this.sharedListener_.bind(this));
        if (this.path_ === "") {
            this.key_ = null;
            this.parentPath_ = null;
        }
        else {
            var index = this.path_.lastIndexOf("/");
            this.key_ = this.path_.substring(index + 1);
            this.parentPath_ = this.path_.substring(0, index);
        }
        if (!this.promise_) {
            this["catch"] = null;
            this["then"] = null;
        }
        if (this.queried_) {
            this["push"] = null;
            this["remove"] = null;
            this["set"] = null;
            this["update"] = null;
        }
    }
    Object.defineProperty(MockRef.prototype, "content_", {
        get: function () {
            return this.database_.content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "key", {
        get: function () {
            return this.key_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "parent", {
        get: function () {
            if (this.key_ === null) {
                return null;
            }
            return new MockRef({
                app: this.app_,
                database: this.database_,
                emitters: this.emitters_,
                path: this.parentPath_
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "path", {
        get: function () {
            return this.path_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "queried_", {
        get: function () {
            return !lodash.isEmpty(this.query_);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "ref", {
        get: function () {
            return this.queried_ ? new MockRef({
                app: this.app_,
                database: this.database_,
                emitters: this.emitters_,
                path: this.path_
            }) : this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MockRef.prototype, "root", {
        get: function () {
            if (this.key_ === null) {
                return this;
            }
            return new MockRef({
                app: this.app_,
                database: this.database_,
                emitters: this.emitters_,
                path: null
            });
        },
        enumerable: true,
        configurable: true
    });
    MockRef.prototype.catch = function (rejector) {
        if (this.promise_) {
            return rejector ?
                this.promise_.catch(rejector) :
                this.promise_.catch();
        }
        throw new Error("No internal promise.");
    };
    MockRef.prototype.child = function (path) {
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'child'.");
        }
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: json.join(this.path_, path)
        });
    };
    MockRef.prototype.endAt = function (value, key) {
        this.assertEndAt_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { endAt: value, key: key })
        });
    };
    MockRef.prototype.equalTo = function (value, key) {
        this.assertEqualTo_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { equalTo: value, key: key })
        });
    };
    MockRef.prototype.isEqual = function (other) {
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.limitToFirst = function (limit) {
        this.assertLimit_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { limitToFirst: limit })
        });
    };
    MockRef.prototype.limitToLast = function (limit) {
        this.assertLimit_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { limitToLast: limit })
        });
    };
    MockRef.prototype.off = function (eventType, callback, context) {
        var _this = this;
        if (eventType) {
            if (callback) {
                var index = lodash.findIndex(this.refEmitterBindings_, function (binding) { return binding.unboundSuccess === callback; });
                if (index !== -1) {
                    var binding = this.refEmitterBindings_[index];
                    this.refEmitterBindings_.splice(index, 1);
                    this.refEmitter_.off(eventType, binding.boundSuccess);
                    this.refEmitter_.off(eventType + "_error", binding.boundError);
                }
            }
            else {
                var indices_1 = [];
                lodash.each(this.refEmitterBindings_, function (binding, index) {
                    if (binding.type === eventType) {
                        indices_1.push(index);
                        _this.refEmitter_.off(eventType, binding.boundSuccess);
                        _this.refEmitter_.off(eventType + "_error", binding.boundError);
                    }
                });
                indices_1.reverse();
                lodash.each(indices_1, function (index) { return _this.refEmitterBindings_.splice(index, 1); });
            }
        }
        else {
            this.refEmitter_.removeAllListeners();
            this.refEmitterBindings_ = [];
        }
    };
    MockRef.prototype.on = function (eventType, successCallback, errorCallback, context) {
        var _this = this;
        if (errorCallback && (typeof errorCallback !== "function")) {
            context = errorCallback;
            errorCallback = undefined;
        }
        var safeErrorCallback = errorCallback ?
            errorCallback :
            function () { };
        var boundErrorCallback = safeErrorCallback;
        var boundSuccessCallback = successCallback;
        if (context) {
            boundErrorCallback = safeErrorCallback.bind(context);
            boundSuccessCallback = successCallback.bind(context);
        }
        var mockSnapshot = new mock_data_snapshot_1.MockDataSnapshot({
            ref: this
        });
        switch (eventType) {
            case "child_added":
                this.enqueue_("init_child_added", function () {
                    var previousKey = null;
                    if (_this.refEmitter_.listeners("child_added").indexOf(boundSuccessCallback) !== -1) {
                        var error = findError(_this.jsonPath_, _this.database_.content);
                        if (error) {
                            boundErrorCallback(error);
                        }
                        else {
                            lodash.each(mockSnapshot.pairs_(), function (pair) {
                                boundSuccessCallback(mockSnapshot.child(pair.key), previousKey);
                                previousKey = pair.key;
                            });
                        }
                    }
                });
                break;
            case "value":
                this.enqueue_("init_value", function () {
                    if (_this.refEmitter_.listeners("value").indexOf(boundSuccessCallback) !== -1) {
                        var error = findError(_this.jsonPath_, _this.database_.content);
                        if (error) {
                            boundErrorCallback(error);
                        }
                        else {
                            boundSuccessCallback(mockSnapshot);
                        }
                    }
                });
                break;
            default:
                break;
        }
        this.refEmitterBindings_.push({
            boundError: boundErrorCallback,
            boundSuccess: boundSuccessCallback,
            type: eventType,
            unboundError: errorCallback || null,
            unboundSuccess: successCallback
        });
        this.refEmitter_.on(eventType, boundSuccessCallback);
        this.refEmitter_.on(eventType + "_error", boundErrorCallback);
        return successCallback;
    };
    MockRef.prototype.once = function (eventType, successCallback, errorCallback, context) {
        var _this = this;
        if (errorCallback && (typeof errorCallback !== "function")) {
            context = errorCallback;
            errorCallback = undefined;
        }
        return new Promise(function (resolve, reject) {
            var listener = _this.on(eventType, function (snapshot, previousKey) {
                _this.off(eventType, listener);
                if (successCallback) {
                    successCallback.call(context, snapshot, previousKey);
                }
                resolve(snapshot);
            }, function (error) {
                _this.off(eventType, listener);
                if (errorCallback) {
                    errorCallback.call(context, error);
                }
                reject(error);
            });
        });
    };
    MockRef.prototype.onDisconnect = function () {
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.orderByChild = function (path) {
        this.assertOrder_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { orderByChild: path })
        });
    };
    MockRef.prototype.orderByKey = function () {
        this.assertOrder_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { orderByKey: true })
        });
    };
    MockRef.prototype.orderByPriority = function () {
        this.assertOrder_();
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.orderByValue = function () {
        this.assertOrder_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { orderByValue: true })
        });
    };
    MockRef.prototype.push = function (value, callback) {
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'push'.");
        }
        var childRef = this.child(getPushedKey());
        return new MockRef({
            app: childRef.app_,
            database: childRef.database_,
            emitters: this.emitters_,
            path: childRef.path_,
            promise: (value === undefined) ?
                Promise.resolve(childRef) :
                childRef.set(value, callback).then(function () { return childRef; })
        });
    };
    MockRef.prototype.remove = function (callback) {
        var _this = this;
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'remove'.");
        }
        var previousContent = this.database_.content;
        return new Promise(function (resolve, reject) {
            _this.enqueue_("remove", function () {
                try {
                    var error = findError(_this.jsonPath_, _this.database_.content);
                    if (error) {
                        throw error;
                    }
                    if (_this.jsonPath_.length === 0) {
                        _this.database_.content = {};
                    }
                    else if (json.has(_this.database_.content, _this.jsonPath_)) {
                        _this.database_.content = json.remove(_this.database_.content, _this.jsonPath_);
                        json.prune(_this.database_.content, _this.jsonPath_);
                    }
                    _this.rootEmitter_.emit("content", {
                        content: _this.database_.content,
                        previousContent: previousContent
                    });
                    if (callback) {
                        callback(null);
                    }
                    resolve();
                }
                catch (error) {
                    if (callback) {
                        callback(error);
                    }
                    reject(error);
                }
            });
        });
    };
    MockRef.prototype.set = function (value, callback) {
        var _this = this;
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'set'.");
        }
        if (value === null) {
            return this.remove();
        }
        var previousContent = this.database_.content;
        return new Promise(function (resolve, reject) {
            _this.enqueue_("set", function () {
                try {
                    validateKeys(value);
                    value = json.clone(value);
                    var error = findError(_this.jsonPath_, _this.database_.content);
                    if (error) {
                        throw error;
                    }
                    if (_this.jsonPath_.length === 0) {
                        _this.database_.content = value;
                    }
                    else {
                        _this.database_.content = json.set(_this.database_.content, _this.jsonPath_, value);
                    }
                    _this.rootEmitter_.emit("content", {
                        content: _this.database_.content,
                        previousContent: previousContent
                    });
                    if (callback) {
                        callback(null);
                    }
                    resolve();
                }
                catch (error) {
                    if (callback) {
                        callback(error);
                    }
                    reject(error);
                }
            });
        });
    };
    MockRef.prototype.setPriority = function (priority, callback) {
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.setWithPriority = function (value, priority, callback) {
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.startAt = function (value, key) {
        this.assertStartAt_();
        return new MockRef({
            app: this.app_,
            database: this.database_,
            emitters: this.emitters_,
            path: this.path_,
            query: lodash.extend({}, this.query_, { key: key, startAt: value })
        });
    };
    MockRef.prototype.stats_ = function () {
        var stats = {
            listeners: {
                child_added: 0,
                child_changed: 0,
                child_moved: 0,
                child_removed: 0,
                total: 0,
                value: 0
            }
        };
        this.refEmitterBindings_.forEach(function (binding) {
            ++stats.listeners[binding.type];
            ++stats.listeners.total;
        });
        return stats;
    };
    MockRef.prototype.then = function (resolver, rejector) {
        if (this.promise_) {
            return this.promise_.then(resolver, rejector);
        }
        throw new Error("No internal promise.");
    };
    MockRef.prototype.toJSON = function () {
        throw mock_error_1.unsupported_();
    };
    MockRef.prototype.toString = function () {
        var base = lodash.trimEnd(this.app_.options["databaseURL"] || "", "/");
        return base + "/" + this.path_;
    };
    MockRef.prototype.transaction = function (updateCallback, completeCallback, applyLocally) {
        var _this = this;
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'transaction'.");
        }
        var previousContent = this.database_.content;
        return new Promise(function (resolve, reject) {
            _this.enqueue_("transaction", function () {
                try {
                    var previousValue = json.clone(json.get(_this.database_.content, _this.jsonPath_));
                    var updatedValue = updateCallback(previousValue);
                    var committed = updatedValue !== undefined;
                    if (committed) {
                        if (_this.jsonPath_.length === 0) {
                            _this.database_.content = updatedValue;
                        }
                        else {
                            _this.database_.content = json.set(_this.database_.content, _this.jsonPath_, updatedValue);
                        }
                    }
                    var snapshot = new mock_data_snapshot_1.MockDataSnapshot({
                        ref: _this
                    });
                    if (completeCallback) {
                        completeCallback(null, committed, snapshot);
                    }
                    resolve({ committed: committed, snapshot: snapshot });
                    _this.rootEmitter_.emit("content", {
                        content: _this.database_.content,
                        previousContent: previousContent
                    });
                }
                catch (error) {
                    if (completeCallback) {
                        completeCallback(error, false, null);
                    }
                    reject(error);
                }
            });
        });
    };
    MockRef.prototype.update = function (values, callback) {
        var _this = this;
        if (this.queried_) {
            throw mock_error_1.unsupported_("Queries do not support 'update'.");
        }
        var previousContent = this.database_.content;
        return new Promise(function (resolve, reject) {
            _this.enqueue_("update", function () {
                try {
                    validateKeysOrPaths(values);
                    lodash.each(values, function (value, key) {
                        var jsonPath = toJsonPath(json.join(_this.jsonPath_, key));
                        var error = findError(jsonPath, _this.database_.content);
                        if (error) {
                            throw error;
                        }
                        if (value === null) {
                            _this.database_.content = json.remove(_this.database_.content, jsonPath);
                            json.prune(_this.database_.content, jsonPath);
                        }
                        else {
                            _this.database_.content = json.set(_this.database_.content, jsonPath, json.clone(value));
                        }
                    });
                    _this.rootEmitter_.emit("content", {
                        content: _this.database_.content,
                        previousContent: previousContent
                    });
                    if (callback) {
                        callback(null);
                    }
                    resolve();
                }
                catch (error) {
                    if (callback) {
                        callback(error);
                    }
                    reject(error);
                }
            });
        });
    };
    MockRef.prototype.assertEndAt_ = function () {
        if (this.query_.endAt !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified end at.");
        }
        if (this.query_.equalTo !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified equal to.");
        }
        if ((this.query_.startAt !== undefined) && (this.query_.limitToFirst || this.query_.limitToLast)) {
            throw mock_error_1.error_("database/query", "Already specified start at and limit.");
        }
    };
    MockRef.prototype.assertEqualTo_ = function () {
        if (this.query_.endAt !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified end at.");
        }
        if (this.query_.startAt !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified start at.");
        }
    };
    MockRef.prototype.assertLimit_ = function () {
        if ((this.query_.startAt !== undefined) && (this.query_.endAt !== undefined)) {
            throw mock_error_1.error_("database/query", "Already specified start/end at.");
        }
        if (this.query_.limitToFirst) {
            throw mock_error_1.error_("database/query", "Already limited to first.");
        }
        if (this.query_.limitToLast) {
            throw mock_error_1.error_("database/query", "Already limited to last.");
        }
    };
    MockRef.prototype.assertOrder_ = function () {
        if (this.query_.orderByChild) {
            throw mock_error_1.error_("database/query", "Already ordered by child.");
        }
        if (this.query_.orderByKey) {
            throw mock_error_1.error_("database/query", "Already ordered by key.");
        }
        if (this.query_.orderByPriority) {
            throw mock_error_1.error_("database/query", "Already ordered by priority.");
        }
        if (this.query_.orderByValue) {
            throw mock_error_1.error_("database/query", "Already ordered by value.");
        }
    };
    MockRef.prototype.assertStartAt_ = function () {
        if ((this.query_.endAt !== undefined) && (this.query_.limitToFirst || this.query_.limitToLast)) {
            throw mock_error_1.error_("database/query", "Already specified end at and limit.");
        }
        if (this.query_.equalTo !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified equal to.");
        }
        if (this.query_.startAt !== undefined) {
            throw mock_error_1.error_("database/query", "Already specified start at.");
        }
    };
    MockRef.prototype.enqueue_ = function (name, action) {
        var _this = this;
        this.queue_.push({ action: action, name: name });
        setTimeout(function () {
            if (_this.queue_.length > 0) {
                var filtered = lodash.filter(_this.queue_, function (queued) { return queued.name === "init_child_added"; });
                lodash.each(filtered, function (queued) { queued.action(); });
                filtered = lodash.filter(_this.queue_, function (queued) { return queued.name === "init_value"; });
                lodash.each(filtered, function (queued) { queued.action(); });
                filtered = lodash.filter(_this.queue_, function (queued) { return !/^init_/.test(queued.name); });
                lodash.each(filtered, function (queued) { queued.action(); });
                _this.queue_ = [];
            }
        }, 0);
    };
    MockRef.prototype.sharedListener_ = function (eventType, _a) {
        var _this = this;
        var snapshot = _a.snapshot, previousSnapshot = _a.previousSnapshot;
        if (this.refEmitterBindings_.length === 0) {
            return;
        }
        var error = findError(this.jsonPath_, this.database_.content);
        if (error) {
            this.refEmitter_.emit(eventType + "_error", error);
            return;
        }
        var childEvent = /^child_/.test(eventType);
        var limitQuery = this.query_.limitToFirst || this.query_.limitToLast;
        var pairs = [];
        var pairsIndex = -1;
        var previousKey = null;
        var previousPairs = [];
        var previousPairsIndex = -1;
        if (childEvent) {
            pairs = new mock_data_snapshot_1.MockDataSnapshot({
                ref: this,
                snapshot: snapshot
            }).pairs_();
            pairsIndex = lodash.findIndex(pairs, function (pair) { return pair.key === snapshot.ref.key; });
            previousKey = (pairsIndex <= 0) ? null : pairs[pairsIndex - 1].key;
            previousPairs = new mock_data_snapshot_1.MockDataSnapshot({
                ref: this,
                snapshot: previousSnapshot
            }).pairs_();
            previousPairsIndex = lodash.findIndex(previousPairs, function (pair) { return pair.key === previousSnapshot.ref.key; });
            if (limitQuery) {
                if ((eventType === "child_added") || (eventType === "child_changed")) {
                    lodash.each(lodash.differenceWith(previousPairs, pairs, mock_data_snapshot_1.MockDataSnapshot.pairKeyEquator), function (removedPair) {
                        _this.refEmitter_.emit("child_removed", new mock_data_snapshot_1.MockDataSnapshot({
                            ref: _this,
                            snapshot: previousSnapshot
                        }).child(removedPair.key));
                    });
                }
            }
        }
        if (!childEvent || (pairsIndex !== -1) || (previousPairsIndex !== -1)) {
            this.refEmitter_.emit(eventType, (eventType === "child_removed") ? previousSnapshot : snapshot, previousKey);
        }
        if (childEvent && limitQuery && ((eventType === "child_changed") || (eventType === "child_removed"))) {
            lodash.each(lodash.differenceWith(pairs, previousPairs, mock_data_snapshot_1.MockDataSnapshot.pairKeyEquator), function (addedPair) {
                var index = lodash.findIndex(pairs, function (pair) { return pair.key === addedPair.key; });
                previousKey = (index <= 0) ? null : pairs[index - 1].key;
                _this.refEmitter_.emit("child_added", new mock_data_snapshot_1.MockDataSnapshot({
                    ref: _this,
                    snapshot: previousSnapshot
                }).child(addedPair.key), previousKey);
            });
        }
    };
    return MockRef;
}());
exports.MockRef = MockRef;
function findError(jsonPath, content) {
    if (content === null) {
        return null;
    }
    var parts = jsonPath.split("/").filter(Boolean);
    if (json.has(content, "/.error")) {
        return toError(json.get(content, "/.error"));
    }
    for (var p = 0; p < parts.length; ++p) {
        var path = "" + json.join.apply(null, parts.slice(0, p + 1).concat([".error"]));
        if (json.has(content, path)) {
            return toError(json.get(content, path));
        }
    }
    return null;
    function toError(value) {
        var error = new Error((typeof value === "string") ?
            value :
            value.message || "Unknown message.");
        error["code"] = value.code || "unknown/code";
        return error;
    }
}
function getPushedKey() {
    return firebase_key_1.key();
}
function toJsonPath(path) {
    path = path.replace(/^(http|https):\/\/[^\/]+/, "");
    return (path.length > 0) ? json.slash(path) : "";
}
function toRelativePath(path) {
    return lodash.trim(path).replace(/^(http|https):\/\/[^\/]+/, "");
}
function validateKeys(value) {
    JSON.stringify(value, function (key, value) {
        if (/[\/\.\$\[\]#]/.test(key)) {
            throw new Error("Key ('" + key + "') contains illegal character.");
        }
        return value;
    });
}
function validateKeysOrPaths(value) {
    JSON.stringify(value, function (key, value) {
        if (/[\.\$\[\]#]/.test(key)) {
            throw new Error("Key/path ('" + key + "') contains illegal character.");
        }
        return value;
    });
}
